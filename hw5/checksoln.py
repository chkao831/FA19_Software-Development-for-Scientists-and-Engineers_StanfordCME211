"""checksoln.py: This file verifies that my maze solution generated by 
mazesolver.cpp is valid.
"""

__author__      = "Carolyn (Chih-Hsuan) Kao"
__version__     = "2.7.12"
__email__       = "chkao831@stanford.edu"
__date__        = "Nov 3, 2019"

import math
from math import hypot
import numpy as np
import sys


def createMazeSet(ndMaze,mazeRowSize,mazeColSize):
    """Creates three set that respectively contains pairs of tuple of walls 
    in the maze files, the column index of the entrance of maze, and the 
    column index of the exit of maze. 

    Parameters
    ----------
    ndMaze: nd Array from numpy that stores the maze
    mazeRowSize: int that represents the row size of the maze
    mazeColSize: int that represents the col size of the maze

    Returns
    -------
    MazeTupleSet: a set that contains pairs of tuples representing the 
                  wall in the maze. 
    mazeEntrance: a set that contains a integer indicating the entrance index
    mazeExit: a set that contains a integer indicating the exit index 
    """
    MazeTupleSet = set()  
    MazeFirstRow = set()
    MazeLastRow = set() 
    FullRow = set()
    FullRow = {s for s in range(mazeColSize)}
    for i,item in enumerate(ndMaze):
        if(i==0): 
            pass
        else:
            temp_tuple = tuple()
            temp_tuple = ((ndMaze[i][0],ndMaze[i][1]))
            #get all elements from the first and last row
            if(ndMaze[i][0] == 0):
                MazeFirstRow.add(ndMaze[i][1])
            if(ndMaze[i][0] == mazeRowSize - 1):
                MazeLastRow.add(ndMaze[i][1])
            MazeTupleSet.add(temp_tuple)
    #and then find entrance and exit by subtracting intersection with full
    mazeEntrance = FullRow -  MazeFirstRow.intersection(FullRow)
    mazeExit = FullRow - MazeLastRow.intersection(FullRow)
    return MazeTupleSet,mazeEntrance,mazeExit

def createSolnSet(ndSoln,mazeRowSize,mazeColSize): 
    """Creates three set that respectively contains pairs of tuples representing
    the path of soln file, the column index of the entrance of soln, and the 
    column index of the exit of soln. Additionally, this also returns two 
    integers that indicate whether the row and col from solutin files are
    both within maze bound. 

    Parameters
    ----------
    ndSoln: nd Array from numpy that stores the solution
    mazeRowSize: int that represents the row size of the maze
    mazeColSize: int that represents the col size of the maze

    Returns
    -------
    SolnTupleSet: a set that contains pairs of tuples representing the 
                  path in the solution file. 
    solnEntrance: a set that contains a integer indicating the entrance of soln
    solnExit: a set that contains a integer indicating the exit index of soln
    rowWithinBound: an integer that shows non-zero if out of bound (row)
    colWithinBound: an integer that shows non-zero if out of bound (col)
    """
    SolnTupleSet = set()
    solnEntrance = set()
    solnExit = set()
    rowWithinBound = 0
    colWithinBound = 0
    for i,item in enumerate(ndSoln):
        num1 = ndSoln[i][0]
        if not (0<=num1<=mazeRowSize-1):
            rowWithinBound += 1 #if out of bound, increment by 1
        num2 = ndSoln[i][1]
        if not (0<=num2<=mazeColSize-1):
            colWithinBound += 1 #if out of bound, increment by 1   
        if(num1 == 0): #get the entrance from solution file
            solnEntrance.add(num2) 
        if(num1 == mazeRowSize - 1): #get the exit from solution file
            solnExit.add(num2)
        sol_tuple = tuple((num1,num2))
        SolnTupleSet.add(sol_tuple)
    return SolnTupleSet,solnEntrance,solnExit,rowWithinBound,colWithinBound

def checkIntoWall(MazeTupleSet,SolnTupleSet):
    """Check if solution runs into wall. 
    Parameters
    ---------- 
    MazeTupleSet: A set contains wall in maze (pairs of tuple)
    SolnTupleSet: A set contains path in solution (pairs of tuple)
    
    Returns
    -------
    boolean True if solution does not run into wall; False otherwise.
    """
    ele = MazeTupleSet.intersection(SolnTupleSet)
    if(len(ele)==0): #if the intersection of wall and solution is zero
        return True #means we do not run into wall
    else:
        return False

def checkSameEntranceExit(mazeEntrance,mazeExit,solnEntrance,solnExit):
    """Check if solution and maze got same entrance and exit. 
    Parameters
    ----------
    mazeEntrance: a set that contains entrance col index of maze
    mazeExit: a set that contains exit col index of maze
    solnEntrance: a set that contains entrance col index of solution
    solnExit: a set that contains exit col index of solution
    
    Returns
    -------
    boolean True if same entrance and exit; False otherwise. 
    """
    if((solnEntrance == mazeEntrance) and (solnExit == mazeExit)):
        return True
    else:
        return False

def checkValidOneMove(ndSoln):
    """Check if every two consecutive moves in soln file is valid. 
    Parameters
    ----------
    ndSoln: nd array representing path in solution file

    Returns
    -------
    boolean True if all moves are valid one step; False otherwise.
    """
    for i in range(len(ndSoln)-1):
        x1 = ndSoln[i][0]
        y1 = ndSoln[i][1]
        x2 = ndSoln[i+1][0]
        y2 = ndSoln[i+1][1]
        #take Euclidean distance between two consecutive moves
        #which should be approx. 1.0 if the move is valid
        if not(math.isclose(hypot(x2-x1,y2-y1),1.0)):
            return False
    return True

def checkWithinBound(rowWithinBound,colWithinBound):
    """Check if soln row and col indices are all within maze bound. 
    Parameters
    ----------
    rowWithinBound: an int that has non-zero value if anything out of bound.
    colWithinBound: an int that has non-zero value if anything out of bound.
    
    Returns
    -------
    boolean True if nothing out of bound; False otherwise.
    """
    if(rowWithinBound == 0 and colWithinBound == 0):
        return True
    else:
        return False

if __name__ == "__main__":
    if (len(sys.argv)!=3):
        print('Usage:')
        print('  python3 {} <maze file> <solution file>'.format(sys.argv[0]))
        sys.exit(0)

    mazefile = sys.argv[1]
    solnfile = sys.argv[2]
    #construct nd array using numpy
    ndMaze = np.loadtxt(mazefile,dtype = "int")
    ndSoln = np.loadtxt(solnfile,dtype = "int")

    mazeRowSize = ndMaze[0][0]
    mazeColSize = ndMaze[0][1]

    #Call function and construct sets / capture integers from returned values
    MazeTupleSet,mazeEntrance,mazeExit = \
    createMazeSet(ndMaze,mazeRowSize,mazeColSize)
    
    SolnTupleSet,solnEntrance,solnExit,rowWithinBound,colWithinBound = \
    createSolnSet(ndSoln,mazeRowSize,mazeColSize)

    #Call test functions that return boolean True or False
    notIntoWall = checkIntoWall(MazeTupleSet,SolnTupleSet)
    sameEntranceNExit = \
    checkSameEntranceExit(mazeEntrance,mazeExit,solnEntrance,solnExit)
    oneMoveAtATime = checkValidOneMove(ndSoln)
    solWithinBound = checkWithinBound(rowWithinBound,colWithinBound)

    #Print out result to command line
    if(notIntoWall and sameEntranceNExit and oneMoveAtATime and solWithinBound):
        print("Solution is valid!")
    else:
        print("Solution is not valid.")

